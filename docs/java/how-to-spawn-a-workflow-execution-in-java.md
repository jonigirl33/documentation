---
id: how-to-spawn-a-workflow-execution-in-java
title: How to spawn a Workflow Execution in Java
sidebar_label: Workflow Execution
description: To start a Workflow Execution or send a Signal or Query to a Workflow Execution, you must use a `WorkflowStub`.
tags:
  - java
  - developer-guide
---

To start a Workflow Execution or send a Signal or Query to a Workflow Execution, you must use a `WorkflowStub`.
`WorkflowStub` are proxies generated by the `WorkflowClient`. You can use typed or untyped `WorkflowStub` in the client code.
See [Workflow Client Initialization](/docs/java/how-to-initialize-a-workflow-client-in-java).

A Workflows Execution can be spawned either synchronously or asynchronously.
The `WorkflowClient` provides some static methods, such as `start`, `execute`, `signalWithStart` etc., that help with starting your Workflows asynchronously.

### Synchronous start

A Synchronous start initiates a Workflow and then waits for its completion. The started Workflow will not rely on the invocation process and will continue executing even if the waiting process crashes or was stopped.

Use sync start when you want to start a Workflow Execution and want to block your client thread until the Workflow Execution completes (or fails) and get the results (or error in case of failure).

The following example is a type-safe approach for starting a Workflow Execution synchronously.

```java
 FileProcessingWorkflow workflow = client.newWorkflowStub(
                FileProcessingWorkflow.class,
                WorkflowOptions.newBuilder()
                        .setWorkflowId(workflowId)
                        .setTaskQueue(taskQueue)
                        .build();

// start sync and wait for results (or failure)
String result = workflow.processfile(new Argument());

```

### Asynchronous start

An asynchronous start initiates a [Workflow Execution](/docs/concepts/what-is-a-workflow-execution) and immediately returns a value to the caller.
This is the most common way to start Workflows in a live environment.

You can start Workflow Executions asynchronously with either typed or untyped `WorkflowStub`.

- **Typed WorkflowStub Example**

  ```java
  // create typed Workflow stub
  FileProcessingWorkflow workflow = client.newWorkflowStub(FileProcessingWorkflow.class,
                WorkflowOptions.newBuilder()
                        .setTaskQueue(taskQueue)
                        .setWorkflowId(workflowId)
                        .build());
  // use WorkflowClient.execute (if your Workflow takes in arguments) or WorkflowClient.start (for zero arguments)
  WorkflowClient.start(workflow::greetCustomer);
  ```

- **Untyped WorkflowStub Example**

  ```java
  WorkflowStub untyped = client.newUntypedWorkflowStub("FileProcessingWorkflow", 
                  WorkflowOptions.newBuilder()
                          .setWorkflowId(workflowId)
                          .setTaskQueue(taskQueue)
                          .build());

  // blocks until Workflow Execution has been started (not until it completes)        
  untyped.start(argument);
  ```

If you need to wait for a Workflow Execution to complete after an asynchronous start, the most straightforward way is to call the blocking Workflow instance again.

If `WorkflowOptions.WorkflowIdReusePolicy` is not set to `AllowDuplicate`, then instead of throwing `DuplicateWorkflowException`, it reconnects to an existing Workflow and waits for its completion.

The following example shows how to do this from a different process than the one that started the Workflow Execution.

```java
YourWorkflow workflow = client.newWorkflowStub(YourWorkflow.class, workflowId);

// Returns the result after waiting for the Workflow to complete.
String result = workflow.yourMethod();
```

Another way to connect to an existing Workflow and wait for its completion from another process, is to use `UntypedWorkflowStub`. For example:

```java
WorkflowStub workflowStub = client.newUntypedWorkflowStub(workflowType, workflowOptions);

// Returns the result after waiting for the Workflow to complete.
String result = workflowStub.getResult(String.class);
```

### Recurring start

You can start a Workflow Execution on a regular schedule with [the CronSchedule option](distributed-cron).

### Calling other Workflows

Use `ExternalWorkflowStub` to send Signals to other Workflow Executions, or cancel other running Workflow Executions from within a Workflow Definition.
Workflows can also invoke, and send Signals to, other Workflows purely by name. This helps particularly for executing Workflows written in other language SDKs, as shown in the following example.

```java
@Override
    public String exec() {

        ExternalWorkflowStub externalGoWorkflowStub = Workflow.newUntypedExternalWorkflowStub("simple-workflow-go");

        // Send 10 signals to Go Workflow
        for(int i=0; i < 10; i++) {
            externalGoWorkflowStub.signal("simplesignal", "Hello from Java Workflow: " + i);
        }

        // Receive 10 signals from Go Workflow
        Workflow.await(() -> messageQueue.size() == 10);

        String result = "";
        for(String m : messageQueue) {
            result += m + "\n";
        }
```

Note that you can only send a Signal to other running Workflow Executions.
To send Signals to a Workflow Execution whose status is unknown, use `SignalWithStart`. This method ensures that if the Workflow Execution is in a closed state, a new Workflow Execution is spawned and the Signal is delivered to the running Workflow Execution.
See [Sending Signals](/docs/java/signals) for details.

See [Temporal Polyglot example](https://github.com/tsurdilo/temporal-polyglot) sample for how to execute Workflows written in other language SDKs.
